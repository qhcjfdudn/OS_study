# 가상 메모리의 기초

## 가상 메모리의 개요

컴퓨터마다 크기가 서로 다른 물리메모리에서 일관되게 프로세스를 실행할 수 있는 기술.

### 가상메모리 시스템

가상 메모리는 **프로세스가 바라보는 메모리 영역**과 **메모리 관리자가 바라보는 메모리 영역**으로 나뉜다.

#### 가상 메모리 크기

가상 메모리에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 **물리 메모리(실제 메모리)와 스왑 영역을 합한 크기**이다.

이론적으로 가상메모리의 크기는 무한대. 실제로는 컴퓨터의 물리메모리의 최대 크기로 제한.(하드가 아니라 메모리!)

물리 메모리의 내용 중 일부를 스왑 영역으로 옮긴다. 즉, 물리 메모리의 부족한 부분을 스왑 영역으로 보충. 물메가 꽉 찼을 때 부족하면 스왑아웃으로 내보내고, 몇 개의 프로세스가 끝나면 스왑인으로 가져온다.

DAT(Dynamic Address Translation) : 물메 + 스왑 영역을 합쳐 프로세스가 사용하는 가상 주소를 실제 메모리의 물리 주소로 변환. 이에 메모리 관리자는

- 물리 메모리를 어떤 방법으로 나눌지
- 사용자 프로세스를 어디에 배치할지
- 부족한 물리 메모리를 어떻게 처리할지

#### 가상 메모리의 메모리 분할 방식

물리 메모리에서의 가변 분할 방식이 여기서는 **세그멘테이션**(외부 단편화 때문에 잘 안 쓴다.), 고정 분할 방식이 **페이징**(페이지 관리의 어려움). 따라서 가상 메모리 시스템에서는 둘의 단점을 보완한 세그멘테이션-페이징 혼용 기법 씀.

### 매핑 테이블의 필요성과 역할

매핑 테이블을 통해 프로세스가 물리 메모리에서 어디에 있는지 알 수 있다. 가상 주소는 물리주소나 스왑 영역 중 한 곳에 있다.



## 페이징 기법

매핑 테이블을 여기에서는 **페이지 매핑 테이블**이라 한다. 가상 주소의 분할된 각 영역은 **페이지**, 물리 메모리의 각 영역은 **프레임**. 둘의 크기는 같다!

페이지 테이블은 아래처럼 하나의 열로 구성돼 있다. invalid는 해당 페이지가 스왑 영역에 있다는 의미. 테이블의 크기는 가상 주소의 페이지의 수에 영향을 받는다.

![page_table](./images/08/page_table.png) 



#### 페이징 기법의 주소 변환 과정

``` 
VA = <P, D> -> PA = <F, D> // P: Page, D: Distance(offset), F: Frame, VA: Virtual Address PA: Pysical Address
```

P = (가상 주소 / 한 페이지의 크기)의 몫, D = (가상 주소/ 한 페이지의 크기)의 나머지

### 페이지 테이블 관리

프로세스마다 페이지 테이블이 하나씩 있다. 페이지 테이블은 메모리 관리자가 자주 사용하는 자료구조이므로 필요시 빨리 접근할 수 있어야 한다. 따라서 페이지 테이블은 물리 메모리 영역 중 운영체제 영역의 일부분에 모아 놓는다.

- 페이지 테이블의 크기가 작지 않다. : 32bit CPU에서 한 페이지가 512B인 시스템에서. 물리 메모리의 최대 크기는 4GB. 페이지 테이블의 최대 크기는 약 24.11MB. 이 때 프로세스가 40개라면 전체 페이지 테이블의 크기는 대략 1GB. 으악!
- 페이지 테이블은 운영체제 영역에 들어가는데, 페이지 테이블이 많아지면 운영체제 영역이 늘어나 사용자 영역이 줄어든다.
- 페이지 테이블에 빠르게 접근하기 위해 페이지 테이블 기준 레지스터(Page Table Base Register, PTBR)를 사용한다. 이는 각 PCB에 저장.

### 페이지 테이블 매핑 방식

쉽게 배우는 운영체제 394~401p 참고!



## 세그멘테이션 기법

가변 분할 방식을 이용한 가상 메모리 관리 기법

### 세그멘테이션 기법의 구현

세그멘테이션 테이블을 사용!

![segmentation_table](./images/08/segmentation_table.png) 

- address : 세그멘트의 시작 주소
- limit: 프로세스의 크기(각 세그멘트가 자신이 주어진 공간을 초과하면 안돼서 size보다 limit이 어울림).

장점 : 메모리를 프로세스 단위로 쓰기 때문에, 세그멘테이션 테이블이 작고 간단하다!

단점 : 외부 단편화..



### 세그멘테이션 기법의 주소 변환

```
VA = <S, D> -> PA = <F, D> // S: Segment number, D: Distance(offset)
```

만약 어떤 프로세스의 limit이 200인데, D = 250이 된다면?

-> 메모리 관리자가 **해당 프로세스를 강제 종료**한다. 이러한 오류를 **trap**(자신의 영역을 벗어나는 주소에 접근하거나 숫자를 0으로 나누는 것과 같은 **사용자 의도치 않은 인터럽트**)이라 한다. trap이 발생하면 운영체제는 사용자에게 segmentation fault 메시지를 보낸다.(사용자가 의도한 인터럽트는 **시그널**이라 한다.)



## 세그멘테이션-페이징 혼용 기법

페이징 기법

- 장점 : 메모리를 페이지 단위로 나누어 메모리 관리가 수얼
- 단점 : 페이징 테이블이 크다.

세그멘테이션 기법

- 장점 : 세그멘테이션 테이블의 크기가 작고 단순.
- 단점 : 외부 단편화 발생

### 메모리 접근 권한

읽기, 쓰기, 실행 권한 존재. 이는 프로세스가 메모리에 접근할 때마다(가상 주소가 물리 주소로 변환이 일어날 때마다) 확인하는 것. 권한이 없이 접근하면 trap!

프로세스에서

- 코드 영역 : 읽기, 실행 권한.(쓰기 없다. 프로그램이 자기 자신을 수정하지 않기 때문.)
- 데이터 영역 : 읽기/쓰기 or 읽기 권한.(일반적인 변수는 읽/쓰. 상수는 읽만 가능.)

### 세그멘테이션-페이징 혼용 기법의 도입

쉽게 배우는 운영체제 407~410p 참고!



## 캐시 매핑 기법

쉽게 배우는 운영체제 411~415p 참고!

