# 물리 메모리 관리

CPU의 작업 공간이 **메인메모리**이다. 메모리라 부르자.

## 메모리 관리의 개요

### 메모리 관리의 복잡성

폰노이만 구조의 컴퓨터에서 **메모리는 유일한 작업 공간**이며 모든 프로그램은 메모리에 올라와야 실행이 가능하다. 메모리에는 **사용자 프로세스 뿐 아니라 운영체제 프로세스도 공존**. 컴퓨터를 켜면 부팅(사용자가 컴퓨터를 사용할 수 있는 환경을 마련하는 과정)이 이루어지면서 하드디스크에 저장된 운영체제가 메모리에 올라간다. 운영체제를 비롯해 여러 작업을 동시에 처리할 때 메모리를 어떻게 관리하는가? **메모리 관리 시스템(Memory Management system, MMS)**이 한다.

### 메모리 관리의 이중성

**프로세스 입장에서 작업의 편리함**과 **관리자 입장에서 관리의 편리함**이 충돌을 일으키는 것. 

### 소스코드의 번역과 실행

#### 컴파일러와 인터프리터의 동작

고수준 언어(C, JAVA 등)를 컴퓨터가 이해할 수 있는 저수준 언어(기계어, 어셈블리어)로 바꿔주는 것

- 컴파일러 : 실행하기 전에 코드를 점검하여 오류를 수정하고 최적화함으로써 빠른 실행파일을 만듦(윈도우 운영체제에서 실행 가능한 프로그램의 확장자는 exe 또는 com이다. but unix에서 특별한 옵션 없이 컴파일된 파일은 a.out이다.)
  - 오류 발견
  - 코드 최적화
- 인터프리터 : 주어진 코드를 한줄한줄 실행하는 것(스크립트 언어. BASIC)

#### 컴파일 과정

컴파일은 사용자가 작성한 소스코드를 **목적 코드**로 변환한 후 **라이브러리를 연결**하고 **최종 실행 파일을 만들어 실행**(실행할 때 DLL(Dynamic Link Library)이 적용됨)하는 과정

- **소스코드 작성 및 컴파일** : 사용자가 작성한 코드를 컴파일러로 1차 번역. 목적코드 짠
- **목적 코드와 라이브러리 연결** : 목적 코드가 만들어지면 **라이브러리(자주 사용하는 함수를 시스템 내에 미리 만들어 놓은 것)에 있는 코드를 목적 코드에 삽입(정적 라이브러리)**하여 최종 실행 파일을 만든다. 링커를 통한 라이브러리 연결. 소스 코드에 사용된 라이브러리를 선언된 헤더에서 찾아서 삽입.
- **동적 라이브러리를 포함하여 최종 실행** : 기존 라이브러리가 더 개선된 버전이 나왔다면, 과거에는 라이브러리를 가져와 다시 컴파일 해야 했지만 지금은 사용한 라이브러리의 자리를 비워두고 


