# 프로세스 간 통신

프로세스가 다른 프로세스와 **데이터를 주고 받는 것.** 데이터를 주고 받는 것이 목적.

- 프로세스 내부 데이터 통신 : 하나의 프로세스의 2개 이상의 스레드가 전역 변수나 파일을 이용해 데이터를 주고 받는 것
- 프로세스 간 데이터 통신 : 서로 다른 프로세스 간에 공용 파일, 파이프를 통해 통신하는 것
- 네트워크를 이용한 데이터 통신 : 여러 컴퓨터가 네트워크로 연결될 때, 소켓. 이는 **네트워킹**



### 프로세스 간 통신의 분류

#### 통신 방향에 따른 분류

전이중(소켓), 반이중(무전기..), 단방향(전역변수(공유 메모리라 생각하자), 파이프)

#### 통신 방식에 따른 분류

- 대기가 있는 통신(소켓, 파이프) : 동기화 지원
-  대기가 없는 통신(파일, 전역 변수) : 동기화 미지원. 받는 쪽이 busy waiting하며 계속 감시 해야..



### 프로세스 간 통신의 종류

가장 중요한 것은 **프로세스 동기화**.

#### 전역 변수를 이용한 통신

부모 프로세스에서 전역 변수를 생성하고 fork()를 통해 자식 프로세스를 만들어 통신하는 것. 이게 가능하다고? 공유 메모리로 확장하기 위한 설명인 것인가. 핵심은, 데이터를 수신하기 위한 busy wait.

#### 파일을 이용한 통신

open(), read()/write(), close()

절차

1. 프로세스가 입출력 프로세스에 읽기/쓰기를 요청한다. 

2. 입출력 프로세스는 하드디스크로부터 읽기/쓰기를 수행한다.

운영체제 입장에서 보면 **저장장치의 데이터를 읽고 쓰는 것**도 **일반 프로세스와 입출력 프로세스 간의 통신**이다.

#### 파이프를 이용한 통신

단방향, 동기화. 양방향을 위해 2개의 파이프를 쓴다. 만약 read한 파이프에 write한 데이터가 없다면 대기. 연결된 프로세스가 write하면 바로 대기 해제!

- annonymouse pipe : 일반적. 부모-자식 간, 같은 부모의 자식-자식 간
- named pipe : FIFO(특수한 파일)를 써 서로 관련 없는 프로세스 간 통신

#### 소켓을 이용한 통신

서로 다른 컴퓨터 간 소켓으로 연결.

1. 컴퓨터의 위치를 알아야 하고
2. 여러 프로세스 중 어떤 프로세스와 통신할지

이를 통해 서로의 소켓을 연결하는 작업을 **바인딩**이라 한다.



#### 정리하면

open-read/write-close 구조를 이루는 통신 과정은 동기화를 이룬다.(파일 자체는 동기화가 없지만, fork()하고 wait()으로 동기를 맞춰주는 과정으로 해결 가능)



## 공유 자원과 임계구역

### 공유 자원의 접근

공유 자원(shared resource)은 **여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등**을 말한다.

공유 자원은 누가 언제 읽고 쓰냐에 따라 데이터가 달라지므로, 프로세스들 간 접근 순서를 정해야 한다.

ex) 예금 10만원 저장. 프로세스 A가 예금 확인. B가 예금 확인. 예금에 5만원 추가해 B가 예금 15만원으로 저장. 아까 A가 확인한 10만원에 10만원을 얹어 20만원으로 저장. 최종 예금은 25만원이 아닌 20만원.

위의 예처럼 공유 자원을 병행적으로 읽거나 쓰는 상황을 race condition이 발생했다!



### 임계구역

공유 자원 접근 순서에 따라 실행 결과가 달라지는 영역을 임계구역(critical section)이라 한다. 임계구역에서는 **프로세스들이 동시에 작업해서는 안 된다.** **전역 변수**를 쓸 때, **하드웨어 자원**을 쓸 때.



### 생산자-소비자 문제

input(buf), output(buf), 원형 버퍼와 버퍼의 상태를 확인하기 위한 변수 sum.

input에서는 sum += 1, output에서는 sum -= 1을 수행하는데, 서로 동시에 적용하면 ex) sum = 3일 때 input의 결과는 sum = 4, output의 결과 sum = 2가 되어 데이터가 서로 다른 값을 갖게 될 수가 있다.



### 임계구역 해결 조건

- **상호 배제(mutual exclusion)** : 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없다.

- 한정 대기(bounded waiting) : 어떤 프로세스도 무한 대기 하면 안 된다. 특정 프로세스가 임계구역에 진입하지 못하면 안 된다.
- 진행의 융통성(progress flexibility) : 한 프로세스가 다른 프로세스의 작업을 방해하면 안 된다.



## 임계구역 해결 방법

단순한 방법 : lock. 프로세스가 공유하는 변수는 공유 변수. 임계구역으로 보호되어야 할 부분은 임계구역!



```c
while (lock == true);
lock = true; // 임계구역 잠그기
balance += 10; // 
lock = false; // 동기화
```

위는 불완전하다. 두 프로세스 p1, p2 모두 현재 while 밖이고, p1이 while을 지나고나서 타임 퀀텀이 끝나 문맥교환이 이뤄지고, p2가 다시 뚫고, p1이 다시 뚫으면? 뚫림. 또 이는 busy waiting에 걸린다.



