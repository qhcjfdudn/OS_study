# 물리 메모리 관리

CPU의 작업 공간이 **메인메모리**이다. 메모리라 부르자.

## 메모리 관리의 개요

### 메모리 관리의 복잡성

폰노이만 구조의 컴퓨터에서 **메모리는 유일한 작업 공간**이며 모든 프로그램은 메모리에 올라와야 실행이 가능하다. 메모리에는 **사용자 프로세스 뿐 아니라 운영체제 프로세스도 공존**. 컴퓨터를 켜면 부팅(사용자가 컴퓨터를 사용할 수 있는 환경을 마련하는 과정)이 이루어지면서 하드디스크에 저장된 운영체제가 메모리에 올라간다. 운영체제를 비롯해 여러 작업을 동시에 처리할 때 메모리를 어떻게 관리하는가? **메모리 관리 시스템(Memory Management system, MMS)**이 한다.

### 메모리 관리의 이중성

**프로세스 입장에서 작업의 편리함**과 **관리자 입장에서 관리의 편리함**이 충돌을 일으키는 것. 

### 소스코드의 번역과 실행

#### 컴파일러와 인터프리터의 동작

고수준 언어(C, JAVA 등)를 컴퓨터가 이해할 수 있는 저수준 언어(기계어, 어셈블리어)로 바꿔주는 것

- 컴파일러 : 실행하기 전에 코드를 점검하여 오류를 수정하고 최적화함으로써 빠른 실행파일을 만듦(윈도우 운영체제에서 실행 가능한 프로그램의 확장자는 exe 또는 com이다. but unix에서 특별한 옵션 없이 컴파일된 파일은 a.out이다.)
  - 오류 발견
  - 코드 최적화
- 인터프리터 : 주어진 코드를 한줄한줄 실행하는 것(스크립트 언어. BASIC)

#### 컴파일 과정

컴파일은 사용자가 작성한 소스코드를 **목적 코드**로 변환한 후 **라이브러리를 연결**하고 **최종 실행 파일을 만들어 실행**(실행할 때 DLL(Dynamic Link Library)이 적용됨)하는 과정

- **소스코드 작성 및 컴파일** : 사용자가 작성한 코드를 컴파일러로 1차 번역. 목적코드 짠
- **목적 코드와 라이브러리 연결** : 목적 코드가 만들어지면 **라이브러리(자주 사용하는 함수를 시스템 내에 미리 만들어 놓은 것)에 있는 코드를 목적 코드에 삽입(정적 라이브러리)**하여 최종 실행 파일을 만든다. 링커를 통한 라이브러리 연결. 소스 코드에 사용된 라이브러리를 선언된 헤더에서 찾아서 삽입.
- **동적 라이브러리를 포함하여 최종 실행** : 기존 라이브러리가 더 개선된 버전이 나왔다면, 과거에는 라이브러리를 가져와 다시 컴파일 해야 했지만 지금은 사용한 라이브러리의 자리를 비워두고 컴파일한 후, 실행할 때 라이브러리를 가져와 실행한다. 이렇게 실행될 때 라이브러리가 삽입되는 것을 **동적 라이브러리**라 한다. 이는 새로 컴파일 할 필요가 없어 꿀.



### 메모리 관리자의 역할

**메모리 관리 유닛**(Memory Manage Unit, MMU)이라는 **하드웨어**가 관리.

- 가져오기(fetch) : 프로세스와 데이터를 메모리로 가져오는 작업. 메모리는 일부일 수 있다. ex) 동영상 실행은 플레이어 먼저 가져와 데이터는 일부만 실행하다가 필요하면 더 불러오고!
- 배치(placement) : 위의 프로세스, 데이터를 메모리의 어떤 부분에 올려놓을지 결정. 배치 전에 메모리를 **어떤 크기로 자를 것인지** 중요! paging : 메모리를 같은 크기로 자르는 것. segmentation : 프로세스의 크기에 맞게 자르는 것. 
- 재배치(replacement) : 새로운 프로세스를 가져와야 하는데 메모리가 꽉 찼다면? 다른 프로세스를 하드디스크로 옮겨놓아야 가져올 수 있을 것. **오래된 프로세스를 내보내는 작업**. 앞으로 사용하지 않을 프로세스를 내보내는 것이 성능이 더 좋을 것. 교체 알고리즘(replacement algorithm) 필요.



## 메모리 주소

### 32bit CPU와 62bit CPU의 차이

CPU의 비트는 한 번에 다룰 수 있는 데이터의 최대 크기를 의미.

이 비트를 기준으로 내부 부품들도 제작된다. CPU 내부의 레지스터, ALU, 각종 버스의 크기(대역폭), 버스를 통해 한 번에 옮겨지는 데이터의 크기 전부 통일된다. 32bit면 32bit, 64bit면 64bit

32bit로 나타낼 수 있는 MAR의 공간은 0 ~ 2^32-1만큼 만들 수 있고, 이는 4GB이다. 따라서 **32bit cpu에서 허용하는 메모리의 최대 크기는 4GB**이다. 64bit cpu는 2^64개니까 으마으마하지.. 또 이는 하드웨어 입장에서 바라본 물리 주소 공간이다. 논리 주소 공간은 사용자 입장에서 바라본 것.

일반적으로 메모리는 운영체제 영역과 사용자 영역으로 나뉠 수 있는데, 사용자 영역이 운영체제 영역을 침범하는 것을 막기 위해 경계 레지스터를 사용한다. 얘가 사용자 프로세스가 침범하는지 확인하고, 침범하면 강종시킨당

#### 절대 주소와 상대 주소의 개념

사용자 프로세스가 메모리 400번지에 올라왔다고 하자. 기본적으로 컴파일 된 프로그램의 변수의 주소는 0번지부터 시작한다. 상대 주소를 사용하기 때문. 40번지에 있는 변수를 상대 주소로는 40번지. 절대 주소로는 440번지가 될 것.

#### 상대 주소를 절대 주소로 변환하는 과정

상대 주소에 메모리 관리자의 재배치 레지스터(프로세스 시작 부분의 절대 주소 값이 들어가 있다) 값을 더해 절대 주소를 구한다.



## 단일 프로그래밍 환경에서의 메모리 할당

### 메모리 오버레이(memory overlay)

프로그램의 크기가 실제 메모리(물리 메모리)보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법.

프로그램 전체를 메모리에 올려 놓고 실행하는 것보다 느리지만 메모리가 프로그램보다 작을 때도 실행 가능.

어떤 모듈을 가져오거나 내보낼지는 CPU의 프로그램 카운터(PC, 앞으로 실행할 명령어의 위치를 가리키는 레지스터)가 결정한다.

**하나의 큰 프로그램을 나누어 메모리에 올릴 수 있다**는 건, 반대로 **여러 프로그램을 나누어 메모리에 여러 개를 올릴 수도 있음**을 알자. 

### 스왑

메모리가 모자라서 

쫓겨난 프로세스는 저장장치의 특별한 공간에 보관해야 한다. 이 곳을 **스왑 영역**. 메모리 -> 스왑 영역은 스왑아웃. 스왑 영역 -> 메모리는 스왑인. 스왑 영역은 메모리 관리자가 관리한다. 하드디스크 같은 저장 장치는 저장 장치 관리자가 관리하지만, 스왑 영역에 들어가는 데이터는 다시 돌아가는 데이터가 머무는 곳이기 때문에 저장장치는 장소만 빌려주고 메모리 관리자가 관리하는 것. 프로그램 입장에서~ 스왑 영역도 메모리로 인식한다. 따라서 메모리 공간을 물리 메모리 + 스왑 영역으로 생각. 이는 순수 물리 메모리보다 느리겠지만, 그래도 큰 프로그램을 실행할 수 있다는 것이니. 스왑 영역의 ex) 최대 절전 모드.



## 다중 프로그래밍 환경에서의 메모리 할당

### 메모리 분할 방식

메모리를 어떤 크기로 나눌 것인가는 메모리 배치 정책에 해당.

- **가변 분할 방식(variable-size partitioning)** : 프로세스의 크기에 따라 분할. 한 프로세스가 연속된 공간에 배치되므로, 연속 메모리 할당(contiguous memory allocation)
  - 장점
    - 하나의 프로세스를 연속된 공간에 배치 가능
  - 단점
    - 메모리 관리 복잡. ex) 18kb, 17kb 프로세스가 수행 중 작업을 마쳤는데, 다음에 19kb 이상의 프로세스가 온다면, 각각의 공간에 할당 불가능. 공간을 합쳐야 하는데, 이 때 다른 프로세스도 공간을 옮겨야 하기도.

- **고정 분할 방식(fixed-size partitioning)** : 프로세스의 크기와 상관 없이 메모리를 같은 크기로 나누는 것. 비연속 메모리 할당(noncontiguous memory allocation)
  - 장점
    - 메모리 관리 수월.
  - 단점
    - 쓸모 없는 공간으로 메모리 낭비
- 따라서 현대에서는 **기본적으로 고정, 일부 가변 적용하는 방식!**

### 가변 분할 방식의 메모리 관리

가상 메모리 시스템에서 **세그멘테이션 기법**이라고도 한다. 프로세스를 배치하는 방법과 이에 따른 문제점을 살펴보자!

프로세스의 크기에 맞게 메모리를 분할하여 할당했지만, 이런식으로 연속적으로 할당하면 프로세스가 끝나고 공간이 비었을 때, 다음에 실행되는 게 이보다 큰 프로세스라면 이 공간은 사용하지 못한다. 이로 인해 공간의 작은 조각들이 발생하는 현상을 **단편화(fragmentation)**이라 한다. 그 중에서도 **외부 단편화**라 한다. 프로세스의 바깥쪽에 조각이 발생하기 때문. 이러한 문제를 해결하기 위해

- 메모리 배치 방식(memory placement strategy) : 작은 조각이 발생하지 않게 프로세스를 배치하는 것.
  - 최초 배치(first fit) : 단편화 고려 ㄴ. 프로세스를 메모리에 올릴 수 있는 공간을 찾다가 발견하면 바로 올린당
  - 최적 배치(best fit) : 메모리의 빈 공간을 모두 보고, 적당한 크기 중 가장 작은 공간에 할당. 딱 맞는 공간일 경우 최적. 아니면 아주 작은 조각을 만든다. 
  - 최악 배치(worst fit) : 빈 공간을 모두 보고, 적당한 크기 중 가장 큰 공간에 할당. 배치 후에도 남은 공간이 제법 커서 쓸모 있다. 점점 많이 배치해서 공간이 얼마 없으면 최적이랑 같은 효과.
  - 버디 시스템(buddy system) : 외부 단편화를 완화하는 방법! 고정 분할과 유사하다. 메모리에 프로세스가 올라갈 때, 이 때 메모리를 파티션 한다. 파티션하는 단위는 프로세스에 딱 맞추는 것이 아닌 **반, 반, 반**! 이분으로 나누어 완전히 공간에 할당할 수 있을 때까지 나누어 할당. **합칠 때에 비슷한 작은 조각들끼리 모여 있어서 합치기가 용이**해 외부 단편화를 완화하는 개념. 프로세스가 끝나면 얘를 풀면서 주변의 빈 공간과 함께 합친다. 실제로는 공간을 1/2로 나누면서 메모리를 배분하는 버디 시스템보다 모든 공간을 **똑같은 크기로 나누는 고정 분할 방식이 메모리 관리 측면에서 단순**하기 때문에 버디 시스템보다 고정 분할 방식이 많이 사용되고 있다.
- 조각 모음(defragmentation) : 작은 조각들을 모아서 하나의 큰 덩어리로 만드는 작업.

### 고정 분할 방식의 메모리 관리

가상 메모리 시스템에서 **페이징**이라고도 한다. 가상 분할 방식보다 공간을 효율적으로 관리 가능.  조각 모음도 필요 없음. 현대 메모리 시스템은 고정 분할 방식을 기본으로 한다. 프로세스를 할당하며, 남은 공간이 없을 때 실행되어야 할 프로세스가 스왑 영역으로 갈 수 있다.

#### 내부 단편화

일정한 크기로 나뉜 파티션의 크기보다 작은 프로세스가 올라가면 내부 단편화 발생. 내부 단편화는 다른 프로세스에게 할당해줄 수 없으므로, 애초에 파티션의 크기를 내부 단편화가 최소화 되도록 잘 할당하는 수 밖에. 이걸 어째 함!!(일단 메모리가 모든 프로세스의 크기의 공약수 만큼이라면 내부 단편화는 없을 것. 예를 들어 1KB. 하지만 이건 프로세스가 많이 분할돼!)