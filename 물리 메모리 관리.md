# 물리 메모리 관리

CPU의 작업 공간이 **메인메모리**이다. 메모리라 부르자.

## 메모리 관리의 개요

### 메모리 관리의 복잡성

폰노이만 구조의 컴퓨터에서 **메모리는 유일한 작업 공간**이며 모든 프로그램은 메모리에 올라와야 실행이 가능하다. 메모리에는 **사용자 프로세스 뿐 아니라 운영체제 프로세스도 공존**. 컴퓨터를 켜면 부팅(사용자가 컴퓨터를 사용할 수 있는 환경을 마련하는 과정)이 이루어지면서 하드디스크에 저장된 운영체제가 메모리에 올라간다. 운영체제를 비롯해 여러 작업을 동시에 처리할 때 메모리를 어떻게 관리하는가? **메모리 관리 시스템(Memory Management system, MMS)**이 한다.

### 메모리 관리의 이중성

**프로세스 입장에서 작업의 편리함**과 **관리자 입장에서 관리의 편리함**이 충돌을 일으키는 것. 

### 소스코드의 번역과 실행

#### 컴파일러와 인터프리터의 동작

고수준 언어(C, JAVA 등)를 컴퓨터가 이해할 수 있는 저수준 언어(기계어, 어셈블리어)로 바꿔주는 것

- 컴파일러 : 실행하기 전에 코드를 점검하여 오류를 수정하고 최적화함으로써 빠른 실행파일을 만듦(윈도우 운영체제에서 실행 가능한 프로그램의 확장자는 exe 또는 com이다. but unix에서 특별한 옵션 없이 컴파일된 파일은 a.out이다.)
  - 오류 발견
  - 코드 최적화
- 인터프리터 : 주어진 코드를 한줄한줄 실행하는 것(스크립트 언어. BASIC)

#### 컴파일 과정

컴파일은 사용자가 작성한 소스코드를 **목적 코드**로 변환한 후 **라이브러리를 연결**하고 **최종 실행 파일을 만들어 실행**(실행할 때 DLL(Dynamic Link Library)이 적용됨)하는 과정

- **소스코드 작성 및 컴파일** : 사용자가 작성한 코드를 컴파일러로 1차 번역. 목적코드 짠
- **목적 코드와 라이브러리 연결** : 목적 코드가 만들어지면 **라이브러리(자주 사용하는 함수를 시스템 내에 미리 만들어 놓은 것)에 있는 코드를 목적 코드에 삽입(정적 라이브러리)**하여 최종 실행 파일을 만든다. 링커를 통한 라이브러리 연결. 소스 코드에 사용된 라이브러리를 선언된 헤더에서 찾아서 삽입.
- **동적 라이브러리를 포함하여 최종 실행** : 기존 라이브러리가 더 개선된 버전이 나왔다면, 과거에는 라이브러리를 가져와 다시 컴파일 해야 했지만 지금은 사용한 라이브러리의 자리를 비워두고 컴파일한 후, 실행할 때 라이브러리를 가져와 실행한다. 이렇게 실행될 때 라이브러리가 삽입되는 것을 **동적 라이브러리**라 한다. 이는 새로 컴파일 할 필요가 없어 꿀.



### 메모리 관리자의 역할

**메모리 관리 유닛**(Memory Manage Unit, MMU)이라는 **하드웨어**가 관리.

- 가져오기(fetch) : 프로세스와 데이터를 메모리로 가져오는 작업. 메모리는 일부일 수 있다. ex) 동영상 실행은 플레이어 먼저 가져와 데이터는 일부만 실행하다가 필요하면 더 불러오고!
- 배치(placement) : 위의 프로세스, 데이터를 메모리의 어떤 부분에 올려놓을지 결정. 배치 전에 메모리를 **어떤 크기로 자를 것인지** 중요! paging : 메모리를 같은 크기로 자르는 것. segmentation : 프로세스의 크기에 맞게 자르는 것. 
- 재배치(replacement) : 새로운 프로세스를 가져와야 하는데 메모리가 꽉 찼다면? 다른 프로세스를 하드디스크로 옮겨놓아야 가져올 수 있을 것. **오래된 프로세스를 내보내는 작업**. 앞으로 사용하지 않을 프로세스를 내보내는 것이 성능이 더 좋을 것. 교체 알고리즘(replacement algorithm) 필요.



## 메모리 주소

### 32bit CPU와 62bit CPU의 차이

CPU의 비트는 한 번에 다룰 수 있는 데이터의 최대 크기를 의미.

이 비트를 기준으로 내부 부품들도 제작된다. CPU 내부의 레지스터, ALU, 각종 버스의 크기(대역폭), 버스를 통해 한 번에 옮겨지는 데이터의 크기 전부 통일된다. 32bit면 32bit, 64bit면 64bit





