# 교착 상태

## 교착 상태의 개요

### 교착 상태(Dead lock)의 정의

2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 작업을 더 이싱 진행하지 못하는 상태.

- starving : 운영체제가 잘못된 정책을 사용하여 특정 프로세스의 작업이 지연되는 문제

- 교착 상태 : 여러 프로세스가 작업을 하다 보니 자연스럽게 발생

운영체제가 교통정리 해야 한다.



### 교착 상태의 발생

- 시스템 자원 : 다른 프로세스와 공유할 수 없는 자원을 사용할 때 발생. 내가 프린터를 쓰면서 레코더를 기다리는데, 너가 레코더를 쓰면서 프린터를 기다려.
- 공유 변수 : 한정 대기 문제가 발생하는 예에서, 임계구역에 서로서로 락을 걸어 진입하지 못할 때.
- 응용 프로그램 : DB에서 데이터의 일관성을 위해 lock을 하는데, 교착상태 가능성.



### 자원 할당 그래프

프로세스는 원, 자원을 사각형을 써서 프로세스가 자원을 할당 받았으면 선(프로세스 <- 자원)으로, 기다리고 있다면 점선(프로세스 -> 자원)으로 표기한 그래프.

[식사하는 철학자 문제](https://namu.wiki/w/식사하는 철학자 문제) : 교착상태가 발생하는 예시.



## 교착 상태 필요 조건

### 교착 상태 필요조건

아래의 4가지를 모두 충족 시켜야 교착 상태 발생.

- 상호 배제(mutual exclusion) : 한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 한다. 임계구역으로 보호 된다.
- 비선점(non-preemption) : 사용 중인 자원은 중간에 다른 프로세스가 빼앗을 수 없다.
- 점유와 대기(hold and wait) : 프로세스가 어떤 자원을 할당 받은 상태에서 다른 자원을 기다리는 상태여야 한다.
- 원형 대기(circular wait) : 점유와 대기를 하는 프로세스 간의 관계가 원을 이루어야 한다.

상호 배제, 비선점은 **자원이 어떤 특징을 가지는지**, 점유/대기와 원형 대기는 **프로세스가 어떤 행위를 하고 있는지**를 나타낸다.



## 교착 상태 해결 방법

### 교착 상태 해결 방법

- 예방(prevention) : 위의 4가지 조건이 발생하지 않도록. 이 중 하나라도 막으면 됨! but 잘 안 쓰임
- 회피(avoidance) : 자원 할당량을 조절하여 교착 상태를 해결. 자원을 할당하다가 교착 상태를 유발할 가능성이 있다고 판단되면 할당을 중단하고 지켜보는 것. 실효성 ㄴㄴ..(얼마나 할당하고 하지 않으면 안전하지? 몰라)
- 검출(detection) : 자원 할당 그래프를 모니터링 하며 교착 상태가 발생하는지 살펴본다. 발생하면 회복 단계로 진행.
- 회복(recovery)

각각을 자세히 보자.

#### 교착 상태 예방

1. 상호 배제 예방
   시스템 내에 있는 상호 배타적인 모든 자원, 독점적으로 사용할 수 있는 자원을 없애버린다. 하지만 현실적으로 무리. 공유되지 않아야 하는 자원은 존재하니까!

2. 비선점 예방

   모든 자원을 빼앗을 수 있도록 한다. but 어떤 기준으로 빼앗을지? 빼앗고 얼마나 사용할지 결정이 어렵다. 또 이 방법은 starving 할 수 있다. 에이징으로 해결해도, 결과적으로 비선점해지게 되지. 모순!

3. 점유와 대기 예방

   자원을 점유한 상태에서 다른 자원을 기다리지 못하게 하는 방식. 전부 할당하거나 아예 할당하지 않는 방식(all or nothing). 프로세스의 자원 사용 방식을 변화시키는 데에서 위와는 다름.

   단점

   - **프로세스가 자신이 사용하는 모든 자원을 알기 어렵다.**
   - **자원의 활용성이 떨어진다.** 앞으로 사용할거라면 시기가 좀 늦어도 선점해야해서.
   - **많은 자원을 사용하는 프로세스가 적은 녀석보다 불리하다.**
   - **결과적으로 일괄 작업 방식으로 동작**

4. 원형 대기 예방

   점유와 대기 중인 프로세스들이 원형을 이루지 못하게 막는 방법. 자원을 한 방향으로만 사용해서 해결하려 한다. 자원에 번호를 부여해서 **현재 내가 작은 번호의 자원을 갖고 있다면, 큰 번호의 자원을 할당받을 수 있다. 반대는 안 된다. 자원의 할당 흐름을 고정시켜버린다. 흐름이 원형이 될 수 없도록 구성하는 것.**

   단점

   - **프로세스 작업 진행에 유연성이 떨어진다.**
   - **자원의 번호를 어떻게 부여할 것인가?**

### 교착상태 회피

교착 상태가 발생하지 않는 범위 내에서만 자원을 할당, 아닐 경우 프로세스 대기.

예방은 프로세스의 작업 방식을 제약하지만, 회피는 그렇지 않기 때문에 유연.

**자원의 총 수와 현재 할당된 자원의 수를 기준**으로 **시스템을 안정 상태**와 **불안정 상태**로 나누고 시스템이 안정 상태를 유지하도록 자원을 할당한다. 그렇지만 안정상태라고 교착이 안 일어나는 것 아니고, 불안정이라고 교착이 일어나는 것 아님. 그럴 가능성이 더 큰 것.

#### 은행원 알고리즘

은행에서 대출 해주는 것처럼! 대출 금액이 대출 가능한(안정상태) 범위이면 ㅇㅋ. 아니면 안됨.

전체 자원과 가용 자원은 시스템의 측면, 최대, 할당, 기대 자원은 프로세스 각각의 측면.

- 전체 자원 : 시스템 내 전체 자원의 수
- 가용 자원 : 시스템 내 현재 사용할 수 있는 자원의 수
- 최대 자원 : 각 프로세스가 선언한 최대 자원의 수
- 할당 자원 : 각 프로세스에 현재 할당된 자원의 수
- 기대 자원 : 각 프로세스가 앞으로 사용할 자원의 수(최대 - 할당)

따라서 **안정 상태**:  각 프로세스의 기대 자원과 비교하여 **가용 자원이 크거나 같은 경우가 한 번** 이상인 경우. 따라서 아래처럼 **가용 자원이 어떤 기대자원보다도 작으면 불안정 상태**이다.

![banker](./images/06/banker.png) 

#### 교착 상태 회피의 문제점

- **프로세스가 자신이 사용할 모든 자원을 미리 선언해야 한다.** 쉽지 않기도 하고, 미리 선언한 자원이 정확하지 않으면 교착 상태가 발생할 수 있다.
- **시스템의 전체 자원 수가 고정적이어야 한다.** 일시적인 고장이나 새로운 자원이 추가되는 일이 빈번하므로 시스템의 자원 수는 실제로 유동적이다.
- **자원이 낭비된다.** 실제로 모든 불안정 상태가 교착 상태가 되는 것은 아니다. 프로세스에 따라 최대 자원을 다 사용하지 않고도 작업을 마치기도 한다. 작업을 수행할 수 있는데도 할당하지 않으니, 자원 낭비.



### 교착 상태 검출

OS가 프로세스 작업을 관찰하면서 **교착 상태 발생 여부**를 주시한다. 발견되면, 회복한다.

#### 타임 아웃을 이용

일정 시간 동안 작업이 진행 되지 않은 프로세스를 교착 상태가 발생한 것으로 간주하여 처리!

- **엉뚱한 프로세스가 강종될 수 있다.** 타임 아웃이 꼭 교착 상태에 발생하진 않잖아?
- **모든 시스템에 적용할 수 없다.** 하나의 OS가 관리할 수 있는 범위가 아닐 때. 분산DB의 경우 여러 시스템에 나뉘어 이고 네트워크로 연결되는데, 원격지의 프로세스의 응답이 없는 것이 교착 상태 때문인지, 네트워크 때문인지, 단순히 처리가 늦는지 알 수 없다.

그래도 이 방법을 선호하는 편. **자원 할당 그래프로 확인**하는 방법은 번거로워서.

데이터베이스에서 타임 아웃으로 데이터의 일관성이 깨질 수 있는 문제를 해결하기 위해

- 체크포인트 :  데이터에 접근하며 lock 하기 전에 해당 지점을 표시하는 것
- 스냅샷 : 그 때의 데이터
- 롤백 : 체크포인트로 돌아가는 행위

과정을 거친다.

### 자원 할당 그래프를 이용한 교착 상태 검출

교착 상태가 있는 자원 그래프인지, 없는 자원 그래프인지는 **싸이클 판단**으로 가능하다. 싸이클이 존재하면 교착 상태! 아니라면 아닌 것.

정확하지만, 그래프 그리고 싸이클 판단 하고 계산하는 과정이 어마어마함. 그래서 일정 시간마다 확인하기도.

자원이 단일 자원일 경우 그래도 자원 할당 그래프를 사용하는 게 간단하지만, 멀티 자원일 경우에는 복잡. 유량이 필요할 것.. **대기 그래프와 그래프 감소** 개념이 필요하다. 알고 공부하고 싶게 만드네;



### 교착 상태 회복

교착 상태를 유발한 프로세스를 강제로 종료!

- **일으킨 모든 프로세스를 동시에 종료** : 흠 동시에 종료된 프로세스들이 다시 작업을 시작하면 다시 교착 상태에 빠질 가능성. 다시 실행할 땐 순차적으로 하자. 어떤걸 먼저 할지 기준도 필요.
- **프로세스 중 하나를 골라 순서대로 종료**하면서 나머지 프로세스를 파악. 어떤 것부터 종료할래?
  - 우선순위가 낮은 프로세스를 먼저 종료
  - 위가 같은 경우 작업 시간이 짧은 프로세스를 먼저 종료
  - 위도 같은 경우 자원을 많이 사용하는 프로세스를 먼저 종료

여기서는 **강종과 함께 이러한 프로세스가 실행되기 전에 시스템을 복구하는 일**도 해야 한다. 이는 명령어가 실행될 때마다 체크포인트를 두어, 가장 최근의 쳌포로 돌아가는 식. 근데 이는 작업량이 많아 시스템에 부하. 고로 선택적으로 사용.