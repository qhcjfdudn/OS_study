# CPU 스케줄링

프로세스 스케줄러라고도 한다. **어떤 작업에 CPU를 배정할지 결정하는 것.**

CPU 스케줄링은 규모에 따라 고/중/저수준 스케줄링으로 구분된다.

#### 고수준 스케줄링

장기 스케줄링(long-term scheduling), 작업 스케줄링(job scheduling)

많은 **작업**(운영체제에서 다루는 일의 가장 큰 단위. 1개 또는 여러 개의 프로세스)을 동시에 하면 시스템에 과부하가 걸린다. 규모가 큰 일괄 작업을 처리할 때 사용.

시스템 내의 전체 작업 수를 조절하는 것. 시스템의 상황을 고려하여 승인/거절. 이를 통해 동시에 실행 가능한 프로세스의 총 개수가 정해진다.

#### 저수준 스케줄링

어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지. 프로세스 상태 변화를 시키는 것.

#### 중간 수준 스케줄링

프로세스가 활성화된 후에도 여러 가지 사정으로 시스템에 과부하가 걸릴 수 있다. **중지(suspend)와 활성화(active)로 전체 시스템의 활성화된 프로세스 수를 조절.** 보류!



### 스케줄링의 목적

모든 프로세스가 공평하게 작업하도록 하는 것.

- 공평성 : 
- 효율성 : 
- 안정성 : 
- 확장성 : 
- 반응 시간 보장 : 
- 무한 연기 방지 : 



## 스케줄링 시 고려 사항

### 선점형 스케줄링과 비선점형 스케줄링

- 선점형 스케줄링 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식. ex) 인터럽트. CPU가 인터럽트를 받으면 현재 실행 중인 작업을 중단하고 커널을 깨워서 인터럽트를 처리시키며, 인터럽트 처리가 완료되면 원래의 작업으로 돌아간다.
  - 문맥교환 같은 부가적인 부분은 단점이지만, 빠른 응답 시간을 요구하는 대화형 시스템이나 시분할 시스템에 적합.
  - 여기에도 비선점형 프로세스는 있다. 백업.
- 비선점형 스케줄링 : 위와 반대. 위와 반대로 스케줄러의 작업량이 적고, 문맥 교환에 의한 낭비도 적다.
  - CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 여러 프로세스가 오래 기다리게 되어 전체 시스템의 처리율이 떨어진다. 과거의 일괄 작업(여러 개의 작업을 단일 작업으로 묶어서 일괄 처리하는 시스템. 즉 한 번에 처리한다. 처리가 끝날 때까지 기다려야 함. ) 시스템에서 사용.



### 우선순위

프로세스는 크게 커널 프로세스와 일반 프로세스로 나뉜다. 커널 프로세스의 우선순위가 더 높다.

**일반 프로세스의 우선순위는 사용자가 조절 가능**. unix os에서 nice 명령어를 통해 우선순위를 낮출 수 있다. 높이는 건 관리자가 가능.



### CPU 집중 프로세스와 입출력 집중 프로세스

준비 상태는 CPU를 할당받기 위해 기다리는 상태이므로 실제 작업이 일어나는 것은 실행 상태와 대기 상태. 고로 CPU는 실행 상태 또는 대기 상태. 각각을 CPU 버스트, 입출력 버스트라 한다. 두 프로세스가 공존할 땐, 입출력 버스트를 실행 상태로 옮기는 게 더 효율적. 그렇게 되면 입출력을 받기 위해 대기로 넘어가면서 CPU를 다음 프로세스에게 할당할 것이기 때문. **입출력 프로세스의 우선순위를 더 높이는 게 작업 효율이 좋다.**



### 전면 프로세스와 후면 프로세스

- 전면 프로세스 : GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스. 현재 입출력을 사용하는 프로세스.
- 압축 프로그램처럼 입력 없이 동작하기 때문에 일괄 작업 프로세스라고 한다. 전면 프로세스는 사용자의 요구에 즉각 반응해야 하기 때문에 우선순위가 더 높다.



#### 우선순위 차이 정리

커널 프로세스 > 일반 프로세스

전면 프로세스 > 후면 프로세스

대화형 프로세스 > 일괄 처리 프로세스

입출력 집중 프로세스 > CPU 집중 프로세스



## 다중 큐

### 준비 상태의 다중 큐

우선순위에 따라 여러 개의 큐를 사용.

- 고정 우선순위 방식 : 프로세스의 우선순위가 프로세스가 끝날 때까지 고정된 방식. 구현 쉽다. 효율 떨어진다.
- 변동 우선순위 방식 : 위와 반대. 우선순위를 바꾸기 위해 **반전 우선순위(priority inversion)** 사용



### 대기 상태의 다중 큐

시스템 내에서는 다양한 종류의 입출력장치가 있다. 같은 입출력을 요구한 프로세스끼리 모아놓는다.

준비 상태의 다중 큐와 대기 상태의 다중 큐는 차이가 있다. **준비 큐는 한 번에 하나의 프로세스를 CPU에 할당**하는 반면, **대기 큐는 여러 개의 프로세스 제어 블록을 동시에 꺼내어 준비 상태로 옮긴다.** 많은 입출력 장치의 입출력이 동시에 끝날 수 있기 때문. **인터럽트 벡터**를 사용.



## 인터럽트 처리

### 인터럽트 개념

입출력뿐만 아니라 시스템을 보호하는 데 매우 중요한 작업!

과거의 순차적 프로그래밍에서는 어떤 버튼이 만약 눌린다면.. 이를 확인하기 위해 버튼을 주기적으로 확인한다. 비효율적. 요즘은 **버튼이 눌리면 프로세스에 알려준다. 이벤트 드리븐.** 입출력에 있어 앞의 경우를 **폴링**, 후자를 **인터럽트**라 한다.

입출력 말고도 ctrl+c같은 종료는 사용자 인터럽트, 어떤 프로세스가 다른 프로세스의 메모리 영역을 침범하면 CPU의 메모리 관련 레지스터가 인터럽트를 발생시켜 해당 프로세스를 강제 종료시킨다.



### 동기적 인터럽트와 비동기적 인터럽트

동기적 인터럽트는 사용자 인터럽트, 비동기적은 하드웨어적인 오류로 발생하는 인터럽트라 생각하자.



### 인터럽트 처리 과정

**인터럽트 번호와 함수의 쌍.** ex) 윈도우의 최소화 버튼은 창을 작게 만드는 함수가 정의돼 있다.

**인터럽트 번호를 IRQ(Interrupt ReQuest), 이를 이용해 인터럽트 식별.** 한 순간에 여러 개 발생할 수 있어서 **인터럽트 벡터**를 사용. 인터럽트 벡터에 있는 2번 인터럽트의 값이 0에서 1이 되는 건, 인터럽트 되었다~ 이에 해당하는 인터럽트 핸들러를 호출한다~ 핸들러는 사용자가 정의, 제거 가능.

#### 처리 과정

1. 인터럽트 발생 -> 실행 중인 프로세스 정지(대기 큐로 가겠지) 및 현재 프로세스 관련 정보 저장
2. 인터럽트의 우선순위를 고려하여 인터럽트 처리 순서 결정
3. 순서에 맞게 인터럽트 핸들러로 동작 수행.
4. 인터럽트 처리를 마치면 일시 정지된 프로세스가 다시 실행(준비로 이동하는거 아닌가)되거나 종료된다. 입출력이었다면 실행될 것, 오류였다면 종료될 것.



### 인터럽트와 이중 모드

프로세스는 크게 커널 프로세스와 사용자 프로세스로 구분.

- 커널 모드 : 운영체제와 관련된 커널 프로세스가 실행된 상태
- 사용자 모드 : 사용자 프로세스가 실행된 상태

사용자가 시스템 호출을 통해 커널의 프로세스를 실행하며 사용자 모드, 커널 모드를 왔다리갔다리! **이중 모드**는 운영체제가 자원을 보호하기 위해 사용하는 기법.

사용자가 커널모드로 진입할 수 있는 경우는 시스템 호출을 사용하거나, 인터럽트에 의해서.





## 스케줄링 알고리즘

크게 비선점형/선점형 알고리즘. 요새 비선점형은 잘 안 쓰임.

- 비선점형 알고리즘 : FCFS, SJF, HRN
- 선점형 알고리즘 : 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐
- 둘 다 : 우선순위



#### 스케줄링 알고리즘의 선택 기준

- CPU 사용률
- 처리량
- 대기 시간 : 프로세스 생성 후 실행되기 전까지의 시간
- 응답 시간 : 프로세스 생성 후 **첫 번째 반응**까지의 시간
- 반환 시간 : 프로세스 생성 후 종료될 때까지의 시간



### 스케줄링 알고리즘의 종류

#### 비선점형

#### FCFS(First Come First Served) 스케줄링

먼저 온 게 먼저 처리되어 나간다. 비선점형. 옛날 구시대 일괄 작업 시스템. 단순하고 공평하나, 처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들의 대기시간이 넘나 길어진다. 작업 효율 저하. **정말 안 씀.**

#### SJF(Shortest Job First) 스케줄링

실행시간이 가장 짧은 프로세스 먼서 실행! FCFS에 비해서 평균 대기시간이 줄어들어 효율적.

단점

- 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다.
- 공평하지 못하다. 실행시간이 긴 프로세스는 한없이 실행되지 못해 startvation 상태에 빠질 수 있다. 에이징(aging, 프로세스가 양보할 수 있는 상한선을 두는 방식)으로 완화 가능하나, 상한선을 어떻게 두느냐에 따라 결국 한계가 있다. **잘 안 씀.**

#### HRN(Highest Response Ratio Next) 스케줄링

최고 응답률 우선! 우선순위를 '(대기 시간 + CPU 사용 시간) / CPU 사용 시간'으로 매긴다. (맨 첨에 대기시간이 0인 프로세스 빼고) 우선순위(수치)가 클수록 먼저 처리. 대기시간이 긴 프로세스의 우선순위를 높여 SJF보다 나아 보이지만, **여전히 공평하지 않아 ㅃㅇ.**



#### 선점형

#### 라운드 로빈 스케줄링

순환 순서 방식.. 할당 받은 타임 슬라이스 동안 작업하다가, 덜 끝나면 준비 큐의 맨 뒤로 간다.

FCFS보다 평균 대기 시간이 조금 더 나아 보인다.(프로세스의 입력 상태에 따라 같기도 하다.) 평균 대기 시간이 만약 같다면, 문맥 교환에 따른 추가 시간 때문에 라운드로빈이 더 안 좋다. 타임 슬라이스를 문맥 교환에 드는 시간까지 고려해서 설정해야 한다.(이걸 어케 함?)

- 타임 슬라이스가 큰 경우 : FCFS와 같을 것.
- 타임 슬라이스가 작은 경우 : 프로세스들이 동시에 실행되는 것처럼 느끼겠지만, 문맥 교환의 오버헤드 어쩔

#### SRT(Shortest Remaining Time) 스케줄링

SJF의 선점형 버전. 당연히 starving하게 된다. 거기다 SJF에는 없던 문맥교환의 오버헤드까지 추가된다. 고로 안 쓴다!

#### 우선순위 스케줄링

프로세스의 중요도에 따라 우선순위 부여!

위에 배운 SJF, HRN, SRT 다 우선순위 스케줄링으로 표현 가능!

고정/변동 우선순위 알고리즘 적용 가능~

but 우선순위 스케줄링 자체는 **공평성을 위배, starving 발생, 우선순위를 매번 바꿔야 하는 오버헤드**까지 제법 재앙인데, **커널 프로세스의 우선순위가 일반 프로세스의 우선순위보다 높아야** 한다와 같은 우선순위를 설정함으로, **시스템의 효율성보다는 프로세스의 중요도에 따라 우선순위를 매기는 것**을 택한다.

#### 다단계 큐(multilevel queue) 스케줄링

우선순위에 따라 준비큐를 여러 개 사용하는 방식. 그리고 나뉘어진 각 큐는 라운드로빈(편한대로 다르게 할 수도 있다. FCFS를 써도 되지). 우선순위는 고정형을 사용. 큐가 다양하다보니, 각 **큐마다 타임 슬라이스를 다르게 적용**할 수 있다. -> **우선순위에 따라 타임 슬라이스를 다르게 적용** 가능. ex) 전면 프로세스는 타임 슬라이스를 짧게 해 동시성을 키우고, 후면은 반대로. but, starving할 수도 있지. 우선순위가 밀려 공평하지 못하므로. 그래서

#### 다단계 피드백 큐(multilevel feedback queue) 스케줄링

다단계 큐와 다른 점은 고정 우선순위가 아니라는거. **CPU를 할당하고 나면 우선순위가 낮아진다.** 물론 커널 프로세스가 일반 프로세스의 큐에 삽입되지는 않는다. 또, **우선순위가 낮아질수록 타임 슬라이스가 크다.** 우선순위를 조정한다고 해도 여전히 우선순위가 낮은 프로세스들은 CPU를 할당하기 어려워서, 어렵게 잡은 기회 오래 쓰라고.. **다단계 피드백 큐가 오늘날 운영체제에서 사용하는 방법.**



#### Tip

- 타임 슬라이스는 변동적이다. 각 우선순위 큐의 우선순위에 따라서 CPU를 할당하는 시간이 조절되기 때문.